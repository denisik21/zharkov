## Инициализацию данных

Общие переменные:
fuelPrice - общая цена бензина (можно доработать api для получения актуальных цен на топлево)

cargoVolume - объем заказа
cargoWeight - вес заказа

warehouses - массив складов с параметрами

storeAddress - наш магазин

args - слайс, который хранит аргументы складов для python скрипта

Также в файле main.go указываются ограничения для симплекс метода (в зависимости от этих ограничений симплекс-метод будет определять коэффициенты распределения для каждого склада, чем больше коэффициент у склада, тем лучше он будет нам подходить)

## Работа файла main.go

Вначале определяется latitude и longitude для магазина.

После циклом проходим по всем складам.
Функцией GeocodeAddress мы получаем latitude и longitude склада.
GetDistanceToStore определяется маршрут от склада до магазина и возвращает дистанцию и время (distance, duration).
CalculateTotalCost рассчитывает стоимость доставки. У каждого транспорта есть свои параметры:
CostPerKm - стоимость доставки за 1км
FuelConsumptionPer100Km - расход топлива на 100 км
MaxVolume - максимальный вместимый объем
MaxWeight - максимальная грузоподъемность
По этим параметрам высчитывается общая стоимость доставки (В моей идеи, если в транспорт не вмещается по весу или объему необходимый груз, то на доставку добавляется ещё такой же транспорт).

После всех функций, цикл записывает полученную информацию в слайс args. А дальше запускается python-скрипт с аргументом args.

## Почему симплекс-метод на python?

Почему симплекс метод написан на python? Потому что все известные (мной) библиотеки для линейного программирования на go больше не поддерживаются, по этой причине и используется python

## lp_solver.py

Скрипт считывает данные, такие как стоимость доставки, время в пути и расстояние для каждого склада. Также считываются ограничения на максимальное время и расстояние.

## Целевая функция

Целевая функция (c): Массив costs, содержащий стоимость доставки для каждого склада, задаёт целевую функцию, которую нужно минимизировать.
Формула для минимизации общей стоимости доставки:
Z = ∑(cᵢ \* xᵢ) for i = 1 to n
​
где:

- `Z` — общая стоимость доставки, которую нужно минимизировать
- `cᵢ` — стоимость доставки от склада `i`
- `xᵢ` — переменная, представляющая долю маршрута (склада), откуда будет осуществляться доставка
- `n` — количество складов

## Ограничения

Ограничения (A и b): Ограничения на время (times) и расстояние (distances) формируют строки матрицы A, а максимальные значения для времени и расстояния — это вектор b.

### Ограничение на время

Максимально допустимое время доставки:
Σ (tᵢ \* xᵢ) ≤ Tₘₐₓ for i = 1 to n

где:

- `tᵢ` — время доставки от склада `i`
- `Tₘₐₓ` — максимально допустимое время доставки

### Ограничение на расстояние

Максимально допустимое расстояние доставки:
Σ (dᵢ \* xᵢ) ≤ Dₘₐₓ for i = 1 to n

где:

- `dᵢ` — расстояние от склада `i`
- `Dₘₐₓ` — максимально допустимое расстояние

### Ограничение на сумму долей маршрутов

Равенство долей маршрутов (A_eq и b_eq): Устанавливается ограничение, что сумма долей маршрутов (значения для каждого склада) должна быть равна 1.
Σ xᵢ = 1 for i = 1 to n

где:

- `xᵢ` — доля маршрута от склада `i`
- `n` — количество складов

### Ограничения на неотрицательность

Границы значений (bounds): Устанавливается, что каждый маршрут может быть выбран с долей от 0 до 1.
0 ≤ xᵢ ≤ 1 for i = 1 to n

где:

- `xᵢ` — доля маршрута от склада `i`
- `n` — количество складов

Функция linprog решает задачу минимизации целевой функции с заданными ограничениями, используя метод линейного программирования. В данном случае используется метод "highs".

Ответ метода мы получаем ввиде [0.0, 0.0, 1.0], т. е. 3 склад подходит больше всего при ограничениях: по времени 11 ч, по расстоянию 1000 км. Или [0.6081490840176879, 0.0, 0.39185091598231214] при огранияениях: по времени 11 ч., по расстоянию 300 км.
